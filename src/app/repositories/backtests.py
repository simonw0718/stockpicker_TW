# src/app/repositories/backtests.py
from typing import Dict, Any, Optional
from app.db.conn import get_conn

class BacktestsRepo:
    def create_run(self, db, payload: Dict[str, Any], *, idempotency_key: Optional[str] = None) -> Dict[str, Any]:
        """
        Idempotent 建立 backtest run（SQLite）：
        - 若 schema 有 idempotency_key 欄位，會用 key 去重；同 key 回傳同一筆 run。
        - 若欄位不存在，退化為每次都新建（方便老 DB 運行，不阻擋流程）。
        """
        conn = db or get_conn()
        cur = conn.cursor()

        # 1) 先嘗試用 key 找舊 run（若欄位不存在會噴錯 → 忽略）
        if idempotency_key:
            try:
                row = cur.execute(
                    "SELECT id, created_at FROM backtest_runs WHERE idempotency_key = ?",
                    (idempotency_key,),
                ).fetchone()
            except Exception:
                row = None
            if row:
                return {
                    "run_id": int(row["id"]),
                    "status": "pending",
                    "created_at": row["created_at"],
                }

        # 2) 新建
        strategy_id = int(payload["strategy_id"])
        symbol = payload["symbol"]
        date_start = payload["start_date"]
        date_end = payload["end_date"]
        timeframe = payload.get("timeframe", "1D")

        # 盡量帶 idempotency_key；沒有該欄位就退化為舊 INSERT
        try:
            cur.execute(
                """
                INSERT INTO backtest_runs
                    (strategy_id, param_set_id, symbol_universe, date_start, date_end, timeframe,
                     status, metrics, created_at, finished_at, notes, idempotency_key)
                VALUES (?, NULL, ?, ?, ?, ?, 'pending', NULL, datetime('now'), NULL, NULL, ?)
                """,
                (strategy_id, symbol, date_start, date_end, timeframe, idempotency_key),
            )
        except Exception:
            cur.execute(
                """
                INSERT INTO backtest_runs
                    (strategy_id, param_set_id, symbol_universe, date_start, date_end, timeframe,
                     status, metrics, created_at, finished_at, notes)
                VALUES (?, NULL, ?, ?, ?, ?, 'pending', NULL, datetime('now'), NULL, NULL)
                """,
                (strategy_id, symbol, date_start, date_end, timeframe),
            )

        new_id = cur.lastrowid
        if new_id is None:
            raise RuntimeError("insert failed: no lastrowid")
        conn.commit()

        return {
            "run_id": int(new_id),
            "status": "pending",
            "created_at": self._now_iso(conn),
        }

    def get_run(self, db, run_id: int) -> Optional[Dict[str, Any]]:
        conn = db or get_conn()
        row = conn.execute(
            """
            SELECT id, strategy_id, symbol_universe, date_start, date_end, timeframe,
                   status, metrics, created_at, finished_at, notes
              FROM backtest_runs
             WHERE id=?
            """,
            (run_id,),
        ).fetchone()
        if not row:
            return None

        return {
            "run_id": row["id"],
            "strategy_id": row["strategy_id"],
            "symbol": row["symbol_universe"],
            "timeframe": row["timeframe"],
            "start_date": row["date_start"],
            "end_date": row["date_end"],
            "status": row["status"],
            "metrics_summary": row["metrics"],
            "created_at": row["created_at"],
            "finished_at": row["finished_at"],
        }

    @staticmethod
    def _now_iso(conn) -> str:
        return conn.execute("SELECT datetime('now') as now").fetchone()["now"]

    def complete_run_stub(self, db, run_id: int) -> None:
        """
        測試/Smoke 用：把指定 run 標記為 completed，並塞一筆示範交易到 trades。
        只在 run 當前為 pending 時插入示範交易，避免重複。
        """
        conn = db or get_conn()
        cur = conn.cursor()

        run = cur.execute(
            """
            SELECT id, symbol_universe, status
              FROM backtest_runs
             WHERE id = ?
            """,
            (run_id,),
        ).fetchone()
        if not run:
            return

        # 僅在 pending → completed 時塞一次
        if (run["status"] or "").lower() == "pending":
            sym = run["symbol_universe"] or "TEST"
            # 塞一筆簡易多單
            cur.execute(
                """
                INSERT INTO trades
                    (run_id, symbol, side, entry_ts, entry_price, exit_ts, exit_price,
                     size, pnl, pnl_pct, mae, mfe, tags, notes)
                VALUES
                    (?,      ?,      'long', datetime('now','-1 day'), 100.0, datetime('now'), 105.0,
                     1.0, 5.0, 0.05, NULL, NULL, 'stub', 'auto generated by complete_run_stub')
                """,
                (run_id, sym),
            )

        # 將 run 標記為完成（口徑：completed）
        cur.execute(
            """
            UPDATE backtest_runs
               SET status = 'completed',
                   finished_at = datetime('now')
             WHERE id = ?
            """,
            (run_id,),
        )
        conn.commit()